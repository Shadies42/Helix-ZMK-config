/*
 * Mouse keymap for your overlay (1x9 direct-gpio order)
 *
 * Button order from your overlay:
 *  RC(0,0) Left        (P1.04)
 *  RC(0,1) Right       (P0.08)
 *  RC(0,2) Middle      (P0.06)
 *  RC(0,3) DPI Shift   (P0.11)
 *  RC(0,4) Button1     (P1.13)  -> bind to "1"
 *  RC(0,5) Button2     (P1.11)  -> bind to "2"
 *  RC(0,6) Button3     (P0.10)  -> bind to "3"
 *  RC(0,7) Button4     (P0.09)  -> bind to "4"
 *  RC(0,8) Button5     (P1.06)  -> bind to "5"
 *
 * Encoders:
 *  encoder1 -> vertical scroll (wheel)
 *  encoder2 -> horizontal scroll (h-wheel)
 */

#include <zephyr/dt-bindings/input/input-event-codes.h>

#include <behaviors.dtsi>
#include <behaviors/mouse_keys.dtsi>
#include <behaviors/mouse_key_press.dtsi>
#include <behaviors/mouse_key_toggle.dtsi>
#include <dt-bindings/zmk/keys.h>
#include <dt-bindings/zmk/bt.h>
#include <dt-bindings/zmk/rgb.h>
#include <dt-bindings/zmk/ext_power.h>
#include <dt-bindings/zmk/outputs.h>
#include <dt-bindings/zmk/mouse.h>
#include <dt-bindings/zmk/input_transform.h>

#include <input/processors/report_rate_limit.dtsi>

#define DEF 0
#define UNL 1
#define LHB 2
#define MSC 3

&zip_report_rate_limit {
    limit-ble-only;
};

/ {
    /* --- Input processors (pattern from your example) --- */
    xy_transf: xy_transf {
        compatible = "zmk,input-processor-transform";
        #input-processor-cells = <1>;
        type = <INPUT_EV_REL>;
        x-codes = <INPUT_REL_X>, <INPUT_REL_WHEEL>;
        y-codes = <INPUT_REL_Y>, <INPUT_REL_HWHEEL>;
    };

    xy_scaler: xy_scaler {
        compatible = "zmk,input-processor-scaler";
        #input-processor-cells = <2>;
        type = <INPUT_EV_REL>;
        codes = <INPUT_REL_X>, <INPUT_REL_Y>;
        track-remainders;
    };

    x_scaler: x_scaler {
        compatible = "zmk,input-processor-scaler";
        #input-processor-cells = <2>;
        type = <INPUT_EV_REL>;
        codes = <INPUT_REL_X>;
    };

    to_wheel: to_wheel {
        compatible = "zmk,input-processor-code-mapper";
        #input-processor-cells = <0>;
        type = <INPUT_EV_REL>;
        map = <INPUT_REL_X INPUT_REL_MISC>, <INPUT_REL_Y INPUT_REL_WHEEL>;
    };

    /*
     * PAW3395 device listener
     * Uses &pd0 from your overlay (paw3395 node label)
     */
    mou0_mmv_il {
        compatible = "zmk,input-listener";
        device = <&pd0>;

        /* Scroll layer: turn motion into wheel */
        scroll {
            layers = <MSC>;
            process-next;
            input-processors = <&zip_report_rate_limit 15>
                             , <&xy_transf (INPUT_TRANSFORM_Y_INVERT)>
                             , <&xy_scaler 1 40>
                             , <&x_scaler 0 1>
                             , <&to_wheel>
                             ;
        };

        unlimited {
            layers = <UNL>;
        };

        base {
            layers = <DEF LHB>;
            input-processors = <&zip_report_rate_limit 15>;
        };
    };

    behaviors {
        /*
         * Two-axis scroll behavior (lets us emit HWHEEL and WHEEL events).
         * We'll use two rotate behaviors:
         *  - encoder1 -> MOVE_Y() => vertical wheel
         *  - encoder2 -> MOVE_X() => horizontal wheel
         */
        ec_s: mouse_scroll {
            compatible = "zmk,behavior-input-two-axis";
            #binding-cells = <1>;
            trigger-period-ms = <12>;
            x-input-code = <INPUT_REL_HWHEEL>;
            y-input-code = <INPUT_REL_WHEEL>;
            time-to-max-speed-ms = <177>;
            acceleration-exponent = <0>;
        };

        /* Encoder1 = vertical scroll (wheel) */
        rot_enc_v: sensor_rotate_v {
            compatible = "zmk,behavior-sensor-rotate";
            #sensor-binding-cells = <0>;
            bindings = <&ec_s MOVE_Y(-37)>, <&ec_s MOVE_Y(37)>;
            tap-ms = <65>;
        };

        /* Encoder2 = horizontal scroll (h-wheel) */
        rot_enc_h: sensor_rotate_h {
            compatible = "zmk,behavior-sensor-rotate";
            #sensor-binding-cells = <0>;
            bindings = <&ec_s MOVE_X(-37)>, <&ec_s MOVE_X(37)>;
            tap-ms = <65>;
        };
    };

    /*
     * Combos: structured like your example (optional but handy)
     * key-positions are indices in the keymap order (0..8)
     */
    combos {
        compatible = "zmk,combos";

        /* Toggle Scroll layer using Middle + DPI */
        tog_scroll {
            timeout-ms = <120>;
            key-positions = <2 3>;
            bindings = <&tog MSC>;
            layers = <DEF UNL LHB MSC>;
        };

        /* Toggle Unlimited using Left + Right + DPI */
        tog_unlimited {
            timeout-ms = <120>;
            key-positions = <0 1 3>;
            bindings = <&tog UNL>;
            layers = <DEF UNL LHB MSC>;
        };

        /* Toggle Left-hand swap using Button4 + Button5 */
        mou_btn_swap {
            timeout-ms = <120>;
            key-positions = <7 8>;
            bindings = <&tog LHB>;
            layers = <DEF UNL LHB MSC>;
        };
    };

    keymap {
        compatible = "zmk,keymap";

        /*
         * Layout: 1 row x 9 columns (matches your overlay transform)
         */
        default_layer {
            display-name = "Default";
            bindings = <
                &mkp LCLK
                &mkp RCLK
                &mkp MCLK
                &trans           /* DPI shift placeholder for now */

                &kp N1
                &kp N2
                &kp N3
                &kp N4
                &kp N5
            >;

            /* encoder1 = vertical scroll, encoder2 = horizontal scroll */
            sensor-bindings = <&rot_enc_v &rot_enc_h>;
        };

        unlimited_layer {
            display-name = "Unlimited";
            bindings = <
                &trans &trans &trans &trans &trans &trans &trans &trans &trans
            >;
            sensor-bindings = <&rot_enc_v &rot_enc_h>;
        };

        left_hand_layer {
            display-name = "Left Hand";
            bindings = <
                &mkp RCLK
                &mkp LCLK
                &mkp MCLK
                &trans

                &kp N1
                &kp N2
                &kp N3
                &kp N4
                &kp N5
            >;
            sensor-bindings = <&rot_enc_v &rot_enc_h>;
        };

        MSC_layer {
            display-name = "Scroll";
            bindings = <
                &trans &trans &trans &trans
                &trans &bt BT_SEL 0  &bt BT_SEL 1  &bt BT_SEL 2  &bt BT_CLR
            >;
            sensor-bindings = <&rot_enc_v &rot_enc_h>;
        };
    };
};
